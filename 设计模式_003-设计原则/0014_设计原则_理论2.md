### 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

> 开闭原则【ocp】是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则

扩展性是衡量代码的重要标准

- 如何理解“对扩展开放、修改关闭”？

  - 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

  - 案例：监控报警

    ```php
    //  将课本 java 代码 转换为 php 代码
    class Alert {
      // AlertRule 存储告警规则，可以自由设置
      private AlertRule $rule;
      // Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道
      private Notification $notification;
    	//构造函数
      public function __construct(AlertRule $rule, Notification $notification) {
        $this->rule = rule;
        $this->notification = notification;
      }
    	//检查报警
      public function check($api, $requestCount,$errorCount,$durationOfSeconds) {
        long tps = $requestCount / $durationOfSeconds;
        if (tps > rule->getMatchedRule($api)->getMaxTps()) {
          // NotificationEmergencyLevel 表示通知的紧急程度, 这里当静态变量使用。 伪代码
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
        if (errorCount > rule->getMatchedRule($api)->getMaxErrorCount()) {
          notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
      }
    }
    //注入对象使用
    $result = new Alert(new AlertRule(),new Notification());
    $result->check(···)
    ```

  - **新增功能：当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知**

    ```php
    
    class Alert {
      // ...省略AlertRule/Notification属性和构造函数...
      
      // 改动一：添加参数timeoutCount
      public function check($api, $requestCount,$errorCount, $timeoutCount,$durationOfSeconds) {
        long tps = $requestCount / $durationOfSeconds;
        if (tps > rule.getMatchedRule($api).getMaxTps()) {
           // NotificationEmergencyLevel 表示通知的紧急程度, 这里当静态变量使用。 伪代码
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
        if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
          notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
        
        // 改动二：添加接口超时处理逻辑
        long timeoutTps = $timeoutCount / $durationOfSeconds;
        if (timeoutTps > rule->getMatchedRule($api)->getMaxTimeoutTps()) {
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
      }
    }
    ```

  - 存在问题：

    1. 我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。
    2. 修改了 check() 函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。
  
  - 优化代码：
  
    - 将 check() 函数的多个入参封装成 ApiStatInfo 类；
    - 引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。
  
    ```php
    //以下PHP伪代码是由课程提供的java所翻译
    class Alert {
      private $alertHandlers = [];
      
      public function addAlertHandler(AlertHandler $alertHandler) {
         array_push($this->alertHandlers,alertHandler)
      }
    	
      // 原理就是把需要检查的项目都推送到 $alertHandlers 数组，
      // 循环各个检查机制。使用check方法校验
      public function check(ApiStatInfo $apiStatInfo) {
        //php 实现
        foreach ($this->alertHandlers as $value){
        		$value::check($apiStatInfo)
    		} 
      }
    }
    
    //  参数
    public class ApiStatInfo {//省略constructor/getter/setter方法
      private String api;
      private long requestCount;
      private long errorCount;
      private long durationOfSeconds;
    }
    
    // Handler类【抽象类】
    abstract class AlertHandler {
      protected AlertRule $rule;
      protected Notification $notification;
      //构造函数
      public function __construct(AlertRule $rule, Notification $notification) {
        $this->rule = $rule;
        $this->notification = $notification;
      }
      //抽象方法
      public abstract function check(ApiStatInfo apiStatInfo);
    }
    
    //tps 警报
    class TpsAlertHandler extends AlertHandler {
      //构造函数
      public function __construct(AlertRule $rule, Notification $notification) {
        	//super(rule, notification); //调用父类构造函数 java 用法
       	  parent::__construct(AlertRule $rule, Notification $notification);  
      }
    
      //@Override【重写父类】
      public function check(ApiStatInfo $apiStatInfo) {
        $tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();
        if ($tps > $rule->getMatchedRule($apiStatInfo->getApi())->getMaxTps()) {
          $notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
      }
    }
    
    //错误警报
    class ErrorAlertHandler extends AlertHandler {
      public function __construct(AlertRule rule, Notification notification){
         parent::__construct(AlertRule $rule, Notification $notification);  
      }
    
    	//@Override【重写父类】
      public function check(ApiStatInfo $apiStatInfo) {
        if ($apiStatInfo->getErrorCount()>rule.getMatchedRule($apiStatInfo->getApi())->getMaxErrorCount()) {
          	$notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
      }
    }
    ```
  
    
