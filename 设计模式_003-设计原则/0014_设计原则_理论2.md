### 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

> 开闭原则【ocp】是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则

扩展性是衡量代码的重要标准

- 如何理解“对扩展开放、修改关闭”？

  - 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

  - 案例：监控报警
  ```php
    <details>
      <summary>点击展开</summary>
      //  将课本 java 代码 转换为 php 代码
      class Alert {
        // AlertRule 存储告警规则，可以自由设置
        private AlertRule $rule;
        // Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道
        private Notification $notification;
        //构造函数
        public function __construct(AlertRule $rule, Notification $notification) {
          $this->rule = rule;
          $this->notification = notification;
        }
        //检查报警
        public function check($api, $requestCount,$errorCount,$durationOfSeconds) {
          long tps = $requestCount / $durationOfSeconds;
          if (tps > rule->getMatchedRule($api)->getMaxTps()) {
            // NotificationEmergencyLevel 表示通知的紧急程度, 这里当静态变量使用。 伪代码
            notification->notify(NotificationEmergencyLevel::URGENCY, "...");
          }
          if (errorCount > rule->getMatchedRule($api)->getMaxErrorCount()) {
            notification->notify(NotificationEmergencyLevel::SEVERE, "...");
          }
        }
      }
      // 注入对象使用
      $result = new Alert(new AlertRule(),new Notification());
      $result->check(···)
    </details>
```
    

    

    

    ```html
    <detail>
      <sumary>点击展开</sumary>
     
    //  将课本 java 代码 转换为 php 代码
    class Alert {
      // AlertRule 存储告警规则，可以自由设置
      private AlertRule $rule;
      // Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道
      private Notification $notification;
    	//构造函数
      public function __construct(AlertRule $rule, Notification $notification) {
        $this->rule = rule;
        $this->notification = notification;
      }
    	//检查报警
      public function check($api, $requestCount,$errorCount,$durationOfSeconds) {
        long tps = $requestCount / $durationOfSeconds;
        if (tps > rule->getMatchedRule($api)->getMaxTps()) {
          // NotificationEmergencyLevel 表示通知的紧急程度, 这里当静态变量使用。 伪代码
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
        if (errorCount > rule->getMatchedRule($api)->getMaxErrorCount()) {
          notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
      }
    }
    //注入对象使用
    $result = new Alert(new AlertRule(),new Notification());
    $result->check(···)
    ```

  - **新增功能：当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知**

    ```php
    class Alert {
      // ...省略AlertRule/Notification属性和构造函数...
      
      // 改动一：添加参数timeoutCount
      public function check($api, $requestCount,$errorCount, $timeoutCount,$durationOfSeconds) {
        long tps = $requestCount / $durationOfSeconds;
        if (tps > rule.getMatchedRule($api).getMaxTps()) {
           // NotificationEmergencyLevel 表示通知的紧急程度, 这里当静态变量使用。 伪代码
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
        if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
          notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
        
        // 改动二：添加接口超时处理逻辑
        long timeoutTps = $timeoutCount / $durationOfSeconds;
        if (timeoutTps > rule->getMatchedRule($api)->getMaxTimeoutTps()) {
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
      }
    }
    ```

  - 存在问题：

    1. 我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。
    2. 修改了 check() 函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。
