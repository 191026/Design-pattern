### 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

> 开闭原则【ocp】是 SOLID 中最难理解、最难掌握，同时也是最有用的一条原则

扩展性是衡量代码的重要标准

- 如何理解“对扩展开放、修改关闭”？

  - 添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

  - 案例：监控报警

    ```php
    //  将课本 java 代码 转换为 php 代码
    class Alert {
      // AlertRule 存储告警规则，可以自由设置
      private AlertRule $rule;
      // Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道
      private Notification $notification;
    	//构造函数
      public function __construct(AlertRule $rule, Notification $notification) {
        $this->rule = rule;
        $this->notification = notification;
      }
    	//检查报警
      public function check($api, $requestCount,$errorCount,$durationOfSeconds) {
        long tps = $requestCount / $durationOfSeconds;
        if (tps > rule->getMatchedRule($api)->getMaxTps()) {
          // NotificationEmergencyLevel 表示通知的紧急程度, 这里当静态变量使用。 伪代码
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
        if (errorCount > rule->getMatchedRule($api)->getMaxErrorCount()) {
          notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
      }
    }
    //注入对象使用
    $result = new Alert(new AlertRule(),new Notification());
    $result->check(···)
    ```

  - **新增功能：当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知**

    ```php
    
    class Alert {
      // ...省略AlertRule/Notification属性和构造函数...
      
      // 改动一：添加参数timeoutCount
      public function check($api, $requestCount,$errorCount, $timeoutCount,$durationOfSeconds) {
        long tps = $requestCount / $durationOfSeconds;
        if (tps > rule.getMatchedRule($api).getMaxTps()) {
           // NotificationEmergencyLevel 表示通知的紧急程度, 这里当静态变量使用。 伪代码
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
        if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
          notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
        
        // 改动二：添加接口超时处理逻辑
        long timeoutTps = $timeoutCount / $durationOfSeconds;
        if (timeoutTps > rule->getMatchedRule($api)->getMaxTimeoutTps()) {
          notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
      }
    }
    ```

  - 存在问题：

    1. 我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。
    2. 修改了 check() 函数，相应的单元测试都需要修改（关于单元测试的内容我们在重构那部分会详细介绍）。

  - 优化代码：

    - 将 check() 函数的多个入参封装成 ApiStatInfo 类；
    - 引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。

    ```php
    //以下PHP伪代码是由课程提供的java所翻译
    class Alert {
      private $alertHandlers = [];
      
      public function addAlertHandler(AlertHandler $alertHandler) {
         array_push($this->alertHandlers,alertHandler)
      }
    	
      // 原理就是把需要检查的项目都推送到 $alertHandlers 数组，
      // 循环各个检查机制。使用check方法校验
      public function check(ApiStatInfo $apiStatInfo) {
        //php 实现
        foreach ($this->alertHandlers as $value){
        		$value::check($apiStatInfo)
    		} 
      }
    }
    
    //  参数
    public class ApiStatInfo {//省略constructor/getter/setter方法
      private String api;
      private long requestCount;
      private long errorCount;
      private long durationOfSeconds;
    }
    
    // Handler类【抽象类】
    abstract class AlertHandler {
      protected AlertRule $rule;
      protected Notification $notification;
      //构造函数
      public function __construct(AlertRule $rule, Notification $notification) {
        $this->rule = $rule;
        $this->notification = $notification;
      }
      //抽象方法
      public abstract function check(ApiStatInfo apiStatInfo);
    }
    
    //tps 警报
    class TpsAlertHandler extends AlertHandler {
      //构造函数
      public function __construct(AlertRule $rule, Notification $notification) {
        	//super(rule, notification); //调用父类构造函数 java 用法
       	  parent::__construct(AlertRule $rule, Notification $notification);  
      }
    
      //@Override【重写父类】
      public function check(ApiStatInfo $apiStatInfo) {
        $tps = apiStatInfo.getRequestCount()/ apiStatInfo.getDurationOfSeconds();
        if ($tps > $rule->getMatchedRule($apiStatInfo->getApi())->getMaxTps()) {
          $notification->notify(NotificationEmergencyLevel::URGENCY, "...");
        }
      }
    }
    
    //错误警报
    class ErrorAlertHandler extends AlertHandler {
      public function __construct(AlertRule rule, Notification notification){
         parent::__construct(AlertRule $rule, Notification $notification);  
      }
    
    	//@Override【重写父类】
      public function check(ApiStatInfo $apiStatInfo) {
        if ($apiStatInfo->getErrorCount()>rule.getMatchedRule($apiStatInfo->getApi())->getMaxErrorCount()) {
          	$notification->notify(NotificationEmergencyLevel::SEVERE, "...");
        }
      }
    }
    ```

  - ApplicationContext 

    - 单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作

    ```php
    // 以下PHP伪代码是由课程提供的java所翻译
    class ApplicationContext {
      private AlertRule $alertRule;
      private Notification $notification;
      private Alert $alert;
      
      //初始化参数
      public void initializeBeans() {
        $alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
        $notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
        $alert = new Alert();
        //这里添加检查条件
        $alert->addAlertHandler(new TpsAlertHandler($alertRule, $notification));
        $alert->addAlertHandler(new ErrorAlertHandler($alertRule, $notification));
      }
      
      public function getAlert() { return alert; }
    
      // 饿汉式单例
      private static final ApplicationContext $instance = new ApplicationContext();
      private ApplicationContext() {
        	initializeBeans();
      }
      public static ApplicationContext getInstance() {
        return $instance;
      }
    }
    
    public class Demo {
      public static void main(String[] args) {
        ApiStatInfo $apiStatInfo = new ApiStatInfo();
        // ...省略设置apiStatInfo数据值的代码
        //获取对象，然后电泳getalert()方法，循环检查
        $ApplicationContext->getInstance()->getAlert().check($apiStatInfo);
      }
    }
    ```

  - 最终改动后的：

    ```php
    
    class Alert { // 代码未改动... }
    class ApiStatInfo {//省略constructor/getter/setter方法
      private $api;
      private $requestCount;
      private $errorCount;
      private $durationOfSeconds;
      
      private $timeoutCount; // 改动一：添加新字段
    }
    abstract class AlertHandler { //代码未改动... }
    class TpsAlertHandler extends AlertHandler {//代码未改动...}
    class ErrorAlertHandler extends AlertHandler {//代码未改动...}
    // 改动二：添加新的handler
    public class TimeoutAlertHandler extends AlertHandler {//省略代码...}
    
    public class ApplicationContext {
      private AlertRule alertRule;
      private Notification notification;
      private Alert alert;
      
      public void initializeBeans() {
        alertRule = new AlertRule(/*.省略参数.*/); //省略一些初始化代码
        notification = new Notification(/*.省略参数.*/); //省略一些初始化代码
        alert = new Alert();
        alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
        alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
        // 改动三：注册handler
        alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));
      }
      //...省略其他未改动代码...
    }
    
    public class Demo {
      public static void main(String[] args) {
        ApiStatInfo apiStatInfo = new ApiStatInfo();
        // ...省略apiStatInfo的set字段代码
        apiStatInfo.setTimeoutCount(289); // 改动四：设置tiemoutCount值
        ApplicationContext.getInstance().getAlert().check(apiStatInfo);
    }
    ```

    
