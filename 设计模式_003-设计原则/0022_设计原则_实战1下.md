### 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？

> 设计的问题本身就没有最优解，只有权衡.

- 业务开发包括哪些工作？

  - 接口设计、
  - 数据库设计、
    - 数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动
  - 业务模型设计（也就是业务逻辑）

- 如何设计数据库？

  <img src="/Users/qiyue/Library/Application Support/typora-user-images/image-20211020173350084.png" alt="image-20211020173350084" style="zoom:50%;" />

- 如何设计积分系统的接口？

  - 接口设计要符合单一职责原则，粒度越小通用性就越好。但是粒度太小也会存在问题，比如，一个功能的实现要调用多个小接口，一方面如果接口调用走网络（特别是公网），多次远程接口调用会影响性能；另一方面，本该在一个接口中完成的原子操作，现在分拆成多个小接口来完成，就可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，但另一个接口执行失败了）。所以，为了兼顾易用性和性能，我们可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。

    <img src="/Users/qiyue/Library/Application Support/typora-user-images/image-20211020173624691.png" alt="image-20211020173624691" style="zoom:50%;" />

- 业务模型设计
  - 分为 Controller、Service、Repository 三层、
  - Controller 层负责接口暴露、
  - Repository 层负责数据读写、
  - Service 层负责核心业务逻辑，也就是这里说的业务模型、

- 为什么要分 MVC 三层开发？

  - 分层能起到代码复用的作用
    - 同一个 Repository 可能会被多个 Service 来调用，同一个 Service 可能会被多个 Controller 调用。比如，UserService 中的 getUserById() 接口封装了通过 ID 获取用户信息的逻辑，这部分逻辑可能会被 UserController 和 AdminController 等多个 Controller 使用。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。
  - 分层能起到隔离变化的作用
    - 分层体现了一种抽象和封装的设计思想。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当我们需要替换数据库的时候，比如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动 Repository 层的代码，Service 层的代码完全不需要修改。
    - 除此之外，Controller、Service、Repository 三层代码的稳定程度不同、引起变化的原因不同，所以分成三层来组织代码，能有效地隔离变化。比如，Repository 层基于数据库表，而数据库表改动的可能性很小，所以 Repository 层的代码最稳定，而 Controller 层提供适配给外部使用的接口，代码经常会变动。分层之后，Controller 层中代码的频繁改动并不会影响到稳定的 Repository 层。
  - 分层能起到隔离关注点的作用
    - Repository 层只关注数据的读写。Service 层只关注业务逻辑，不关注数据的来源。Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。
  - 分层能提高代码的可测试性
    - 后面讲单元测试的时候，我们会讲到，单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repsitory 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，我们可以用 mock 的数据源替代真实的数据库，注入到 Service 层代码中。代码的可测试性和单元测试我们后面会讲到，这里你稍微了解即可。
  - 分层能应对系统的复杂性
    - 所有的代码都放到一个类中，那这个类的代码就会因为需求的迭代而无限膨胀。我们知道，当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。
    - 还是那句话，不管是分层、模块化，还是 OOP、DDD，以及各种设计模式、原则和思想，都是为了应对复杂系统，应对系统的复杂性。对于简单系统来说，其实是发挥不了作用的，就是俗话说的“杀鸡焉用牛刀”。
  - BO、VO、Entity 存在的意义是什么？
    - 在前面的章节中，我们提到，针对 Controller、Service、Repository 三层，每层都会定义相应的数据对象，它们分别是 VO（View Object）、BO（Business Object）、Entity（常用实体类，基本和数据表一一对应，一个实体一张表），例如 UserVo、UserBo、UserEntity。在实际的开发中，VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，我们经常需要重复定义三个几乎一样的类，显然是一种重复劳动。
  - 相对于每层定义各自的数据对象来说，是不是定义一个公共的数据对象更好些呢？
    - 实际上，我更加推荐每层都定义各自的数据对象这种设计思路，主要有以下 3 个方面的原因
    - VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。
    - VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。在前面讲到 DRY 原则的时候，针对这种情况，如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。
    - 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，每层都需要定义各自的数据对象，需要做数据对象之间的转化，但是分层清晰。对于非常大的项目来说，结构清晰是第一位的！
  - 既然 VO、BO、Entity 不能合并，那如何解决代码重复的问题呢？
    - https://www.jianshu.com/p/b934b0d72602 【解释名词】
    - 从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。但是，如果你真的有代码洁癖，对于代码重复的问题，我们也有一些办法来解决。
    - 提取公共部分到父类，子类继承，可以在业务演进过程中把公共部分提到父类中。或者把独有的放到子类中。
    - 前面在讲“多用组合，少用继承”设计思想的时候，我们提到，组合也可以解决代码重复的问题，所以，这里我们还可以将公共的字段抽取到公共的类中，VO、BO、Entity 通过组合关系来复用这个类的代码。
  - 代码重复问题解决了，那不同分层之间的数据对象该如何互相转化呢？
    - 不同层调用需要转换数据，一般手动赋值，或者用工具转换。

  - 不知不觉使用了一些规则

    <img src="/Users/qiyue/Library/Application Support/typora-user-images/image-20211020192756939.png" alt="image-20211020192756939" style="zoom:50%;" />

<hr>

- 总结：
  - 为什么要分 MVC 三层开发？
    - 分层能起到代码复用的作用
    - 分层能起到隔离变化的作用
    - 分层能起到隔离关注点的作用
    - 分层能提高代码的可测试性
    - 分层能应对系统的复杂性
  - BO、VO、Entity 存在的意义是什么？
    - 从设计的角度来说，VO、BO、Entity 的设计思路并不违反 DRY 原则，为了分层清晰、减少耦合，多维护几个类的成本也并不是不能接受的。
  - 总结用到的设计原则和思想
    - 从表面上看，做业务开发可能并不是特别有技术挑战，但是实际上，如果你要做到知其然知其所以然，做到透彻理解、真的懂，并不是件容易的事情。深挖一下，你会发现这其中还是蕴含了很多设计原则、思想和模式的。
